Theory
    Sort using an alternate order. decouple object ordering from default data 
    Must be a total order
    with strings there might be many different ways we want to Sort

public interface Comparator<Key> {
    int compare(Key v, Key w);
}

Java System Sort
    Create Comparator object and pass as second argument to sort()
        String[] a;
        Arrays.sort(a, String.CASE_INSENSITIVE_ORDER);  // create alternate order defined by Comparator<String> object

Creating Comparators 

    {   
        public static final Comparator<Student> BY_NAME = new ByName();
        public static final Comparator<Student> BY_SECTION = new BySection();
        
        private final String name;
        private final int section;

        private static class ByName implements Comparator<Student> {
            public int compare(Student v, Student w) {
                reutrn v.name.compareTo(w.name);
            }
        }

        private static class BySection implements Comparator<Student> {
            public int compare(Student v, Student w) {
                return v.section - w.section;
            }
        }
    }
    // convex hull PolarOrder
    public class Point2D
    {
        public final Comparator<Point2D> POLAR_ORDER = new PolarOrder();
        private final double x, y;

        private static int ccw(Point2D a, Point2D b, Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) return -1;   // clockwise
            else if (area > 0) return +1;   // counter-clockwise
            else return 0;
        }

        private class PolarOrder implements Comparator<Point2D> {
            public int compare(Point2D, q1, Point2D q2) {
                double dy1 = q1.y - y;
                double dy2 = q2.y - y;
                if (dy1 == 0 && dy2 == 0) {// p, q1, q2 horizontal }
                else if (dy1 >= 0 && dy2 < 0) return -1;   // q1 above p, q2 below p 
                else if (dy2 >= 0 && dy1 < 0) return +1;    
                else return -ccw(Point2D.this, q1, q2); 
            }
        }
    }

Using Comparators

    public static void sort(Object[] a, Comparator comparator) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            for (int j = i; j > 0 && less(comparator, a[j], a[j - 1]); j--) {
                exch(a, j, j - 1);
            }
        }
    }

    private static boolean less(Comparator c, Object v, Object w) {
        return c.compare(v, w) < 0;
    }




